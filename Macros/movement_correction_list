//movement_correction_list macro

//using Image Stabilizer by Kang Li;http://www.cs.cmu.edu/~kangli/code/Image_Stabilizer.html;
//Modifies the videos in the data folder, shifting correction paramenters, with the translation transform 
///////////////////////////////////////////////////////////////////////////////////
/*Copyright (C) 2016  Francisco J. Maza.
* IFIByNE-CONICET/F.C.E.N., Universidad de Buenos Aires
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
////////////////////////////////////////////////////////////////////////////////////
// 1.7 (20/05/2019):	> intravideo registration now with two ooptions: ImageStabilizer shift coors and shift the images or directly run StackReg over the Video 
// 1.6 (16/05/2019):	> median previous to registration not done, registration is done over raw video
// 1.5 (22/03/2019):	>corrected "close window command if intravideo is checked, otherwise it founds not video to close
// 1.4 (14/01/2019): 	> auto check whether stack time dimension is made of "slices" or "frames", depends on the origin of the data 
//						> 32 bits canceled, in line 245
// 1.3 (03/11/2016):	> header edited
// 1.2 (15/04/2016):	> code edition (indentation, unnecessary lines deleted, etc) 
// 1.1 (13/08/2015):	> dialog box options: intravideo, intervideo corrections. 
// 1.0 (25/06/2014):	> initial version

//**videos from list must have the same size**


macro "movement_correction" {
	// Get the folder path 
	String.resetBuffer;
	DIR_PATH=getDirectory("Select your ImageJ_ImagingAnalysis folder"); //ImageJ_ImagingAnalysis folder should contain the following subfolders :
										//data (containing "Experiment" folder with .tif videos);
										//list (containing experiment list created by "create_list macro");
										//coors (containing roi list coors saved using roi managerAS : "ExperimentName.txt");
										//masks (containing roiset.zip saved using roi manager AS : "ExperimentName.txt.zip");
										//data_deltaF (will contain "Experiment" folder with "deltaF" .tif videos);
										//ImageJ_Output (will receive data results from "measure_bleaching_corrected" macro);
	print("\\Clear");
	print("DIR_PATH :"+DIR_PATH);
	
	//Get all Experiments names
	ALL_EXP=getFileList(DIR_PATH+"data_deltaF");
	EXP_ARRAY=newArray(ALL_EXP.length);
	
	//Create experiment array
	for (i=0; i<ALL_EXP.length; i++) {
		LENGTH=lengthOf(ALL_EXP[i]);
		EXP_ARRAY[i]=substring(ALL_EXP[i],0,LENGTH);
		}
	EXP_ARRAY_WITH_NONE=newArray(EXP_ARRAY.length+1);
	NONE_Array=newArray("");
	EXP_ARRAY_WITH_NONE=Array.concat(NONE_Array,EXP_ARRAY);
	
	
	
	defaults = newArray(EXP_ARRAY.length);
	for (i=0; i<EXP_ARRAY.length; i++) {
		defaults[i] = false;
		}
	if (EXP_ARRAY.length>10) {
		rows = 10;
	  	columns = (EXP_ARRAY.length+10)/10;
	  	}
	if (EXP_ARRAY.length<=10){
		rows= EXP_ARRAY.length+1;
		columns = 1;
		}
	n_checkboxes = rows*columns;
	Dialog.create("Choose Experiment");
	Dialog.addCheckboxGroup(rows,columns,EXP_ARRAY,defaults);
	Dialog.show();

	EXP_ARRAY_SELECTION=newArray(EXP_ARRAY.length);
	for (s=0;s<EXP_ARRAY.length;s++){
		if (Dialog.getCheckbox()==true)EXP_ARRAY_SELECTION[s]=EXP_ARRAY[s];
		else EXP_ARRAY_SELECTION[s]="";
		}
	
	EXP_ARRAY_SELECTION_sorted=Array.copy(EXP_ARRAY_SELECTION); // this is the array for the expeiments selected to be analized, sorted up-down
	Array.sort(EXP_ARRAY_SELECTION_sorted);
	Array.reverse(EXP_ARRAY_SELECTION_sorted);
		
	/*---------------------------------------------------------------------------------------*/
	//Creation of the dialog box
	Dialog.create("Movement correction macro");
	Dialog.addMessage("MOVEMENT");
	Dialog.addCheckbox("Intravideo correction (shift coors from ImageStabilizer plug-in by Kang Li)", false);
	Dialog.addMessage("OR\n");
	Dialog.addCheckbox("Intravideo correction (StackReg plug-in)", false);
	Dialog.addMessage("AND/OR\n");
	Dialog.addCheckbox("Intervideo Shiftcorrection (shift coors from list)", false);
	Dialog.addMessage("\n");
	Dialog.show();
	IntravideoStabilizer=Dialog.getCheckbox();
	IntravideoStackReg=Dialog.getCheckbox();
	Intervideo=Dialog.getCheckbox();
	
	/*--------------------------------------------------------------------------------*/
	for (d=0;d<EXP_ARRAY_SELECTION_sorted.length;d++){	//start loop for selected MULTIPLE experiments
		if (EXP_ARRAY_SELECTION_sorted[d]=="") {
			//setBatchMode("exit and display")
			showStatus("Finished");
			//Creation of the finished dialog box
			Dialog.create("listo!");
			Dialog.addMessage("Finished");
			Dialog.show();
			exit;
			}
		else {
	
			EXP_NAME=EXP_ARRAY_SELECTION_sorted[d];
			EXP_N=substring(EXP_NAME,0,lengthOf(EXP_NAME)-1);
			EXP=substring(EXP_NAME,0,lengthOf(EXP_NAME)-8);
			
			//Get all file names
			ALL_NAMES=getFileList(DIR_PATH+"data_delta/"+EXP_NAME);
			ALL_EXT=newArray(ALL_NAMES.length);
			//Create extensions array
			for (i=0; i<ALL_NAMES.length; i++) {
				LENGTH=lengthOf(ALL_NAMES[i]);
				ALL_EXT[i]=substring(ALL_NAMES[i],LENGTH-4,LENGTH);
				}
			
			// Loop on all files
			
			/*--------------------------------------------------------------------------------------*/
			//Opening list Results table
			LIST_DIR= DIR_PATH +"list/"+EXP_N+"_list"+".txt"; // experiment list location
			
			//List Arrays for reading variables
			
			filestring=File.openAsString(LIST_DIR);
			rows=split(filestring, "\n");
			videoNumber_LIST=newArray(rows.length);
			VIDEO_LIST=newArray(rows.length);
			BIN_LIST=newArray(rows.length);
			StimulusON_LIST=newArray(rows.length);
			StimulusOFF_LIST=newArray(rows.length);
			Stimulus2ON_LIST=newArray(rows.length);
			Stimulus2OFF_LIST=newArray(rows.length);
			ROILIST_LIST=newArray(rows.length);
			xShift_LIST=newArray(rows.length);
			yShift_LIST=newArray(rows.length);
			framestoexcl_LIST=newArray(rows.length);
					
			//make list arrays
			for(i=1; i<rows.length; i++) {
				columns=split(rows[i],"\t");
				videoNumber_LIST[i]=i;
				VIDEO_LIST[i]=columns[2];
				BIN_LIST[i]=columns[3];
				StimulusON_LIST[i]=columns[4];
				StimulusOFF_LIST[i]=columns[5];
				Stimulus2ON_LIST[i]=columns[6];
				Stimulus2OFF_LIST[i]=columns[7];
				ROILIST_LIST[i]=columns[8];
				xShift_LIST[i]=columns[9];
				yShift_LIST[i]=columns[10];
				framestoexcl_LIST[i]=columns[11];
				}
			Array.print(StimulusON_LIST);
			
			/*-----------------------------------------------------------------------------------------------------*/
					
			//Start For loop for VIDEO_LIST
			for (v=1; v<VIDEO_LIST.length; v++) {

				
				// Get the file path and name
				FILE_PATH=DIR_PATH+"data_deltaF/"+EXP_NAME+VIDEO_LIST[v];
				FILE_NAME=File.getName(FILE_PATH);
				FILE_NAME_LENGTH=lengthOf(FILE_NAME);
				FILE_SHORTNAME=substring(FILE_NAME,0,FILE_NAME_LENGTH-4);
					
				print("");	
				print("FILE_PATH:", FILE_PATH);
				print("FILE_NAME:", FILE_NAME);	
				print("FILE_SHORTNAME:", FILE_SHORTNAME);	
				
				
				//set variables from list arrays
				videoNumber=videoNumber_LIST[v];
				bin=BIN_LIST[v];
				VIDEO=VIDEO_LIST[v];
				StimulusON=StimulusON_LIST[v];
				StimulusOFF=StimulusOFF_LIST[v];	
				start_basal=(StimulusON)-5;
				stop_basal=(StimulusON)-1;
				xShift=(-1)*xShift_LIST[v];
				yShift=(-1)*yShift_LIST[v];
				framestoexcl=framestoexcl_LIST[v];
				rois=ROILIST_LIST[v];

				t0=getTime();
				open(FILE_PATH);	
				rename("forintravideo");
				Stack.getDimensions(width, height, channels, slices, frames);
				if (IntravideoStabilizer==true){
					selectWindow("forintravideo");
					if (slices >1) { // check whether the stack is made of "slices" or "frames"
						framesnumber=slices;
						}
					else {
						framesnumber=frames;	
						}
					run("Duplicate...", "title=[forintravideo-1] duplicate range=1-framesnumber");	
					setBatchMode(true);	//run faster, avoid opening images
					//rename("forintravideo");
					//selectWindow("forintravideo");
					//run("Duplicate...", "title=[forintravideo-1] duplicate range=1-200");
					selectWindow("forintravideo-1");	
					//run("Median...", "radius=1 stack");	//median filtering that won't be saved here
					//set and run image stabilizer plug in, template update coefficient set to 1, template should remain the same for every slice
					run("Image Stabilizer", "transformation=Translation maximum_pyramid_levels=1 template_update_coefficient=1 maximum_iterations=200 error_tolerance=0.0000001 log_transformation_coefficients output_to_a_new_stack");//From Kang Li's page(http://www.cs.cmu.edu/~kangli/code/Image_Stabilizer.html): "Once a slice is aligned, the "template" will be updated on the fly using the formula: new_template = a * old_template + (1 - a) * newly_aligned_slice, where "a" is the "template update coefficient" that can be adjusted when the plugin is run." 
					selectWindow("Stablized forintravideo-1");
					run("Close");
					selectWindow("forintravideo-1");	
					run("Close");
					
					/*---------------------------------------------------------------------------------------------*/
					//open txt as string and move frames
					selectWindow("forintravideo-1.log");
					filestring=getInfo("window.contents");
					rows=split(filestring, "\n");
					VideoNumber=newArray(rows.length);
					xshift=newArray(rows.length);
					yshift=newArray(rows.length);
					run("Clear Results");	
						
					//read the shift coors
					for(i=2; i<rows.length; i++) {
						columns=split(rows[i],",");
						VideoNumber[i]=columns[0];
						xshift[i]=parseFloat(columns[2]);
						yshift[i]=parseFloat(columns[3]);
						row=i-2;
						setResult("xShift",row,xshift[i]);
						setResult("yShift",row,yshift[i]);
						}
					updateResults();
					
					//re open file and move frames
					selectWindow("forintravideo");
					//run ("32-bit");
					Stack.getDimensions(width, height, channels, slices, frames);
					if (slices >1) {
						total=slices;
						}	
					else {
						total=frames;
						}
					slice=1;
					i=0;
					while (slice<=total){
						setSlice(slice);
						X=(-1)*parseFloat(getResult("xShift",i));
						Y=(-1)*parseFloat(getResult("yShift",i));
						run("Translate...", "x=X y=Y interpolation=None slice");
						slice +=1;
						i +=1;
						}
					}	//end for intravideo Image stabilizer option checked
				
				if (IntravideoStackReg==true){ //If Intravideo Using StackReg plugin is selected
					selectWindow("forintravideo");
					if (slices >1) { // check whether the stack is made of "slices" or "frames"
						framesnumber=slices;
						}
					else {
						framesnumber=frames;	
						}
					setBatchMode(true);	//run faster, avoid opening images
					run("StackReg", "transformation=Translation");										
					
					}	//end for intravideo StackReg option checked
				/*------------------------------------------------*/
				//Intervideo correction if checked	
				selectWindow("forintravideo");	
				Stack.getDimensions(width, height, channels, slices, frames);
				if (slices >1) { // check whether the stack is made of "slices" or "frames"
					framesnumber=slices;
					}
				else {
					framesnumber=frames;	
					}
				//run("Properties...", "channels=1 slices=framesnumber frames=1" );
				if (Intervideo==true && framesnumber>1){ //nSlices>1){
					run("Translate...", "x=xShift y=yShift interpolation=None stack");
					}
				save(FILE_PATH);
				close("forintravideo");
				
				if (IntravideoStabilizer==true) {
					selectWindow("forintravideo-1.log");
					run("Close");
				}
				
				setBatchMode(false);
				showProgress(d/EXP_ARRAY.length);
				showStatus("Experiment:"+EXP_NAME+"Exp: "+d+"/"+EXP_ARRAY.length+" ETA:"+d2s((getTime()-t0)/1000*((VIDEO_LIST.length-v+1)/(v+1)),1)+" / "+d2s((getTime()-t0)/1000*(VIDEO_LIST.length/(v+1)),1)+" sec");//ETA: "+d2s((getTime()-t0)/1000*((npixel-u+1)/(u+1)),1)+" / "+d2s((getTime()-t0)/1000*(npixel/(u+1)),1)+" sec");
	
				}	//end of For loop videos
					
							
		/*---------------------------------------------------------------------------------------------*/
				
				
					
			}
		
		
		}	//end of loop for MULTIPLE EXPERIMENTS	
	
	//setBatchMode("exit and display");
	showStatus("Finished");
	// Creation of the finished dialog box
	Dialog.create("Listo!");
	Dialog.addMessage("Finished");
	Dialog.show();
		
	}	//end of macro
